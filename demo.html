<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STATIC | Hollywood Demo</title>
    
    <!-- All Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        
        h1 {
            font-size: 8rem;
            margin: 0;
            font-weight: 900;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff0000, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(255,0,0,0.8)); }
            50% { filter: drop-shadow(0 0 40px rgba(0,255,255,1)); }
        }
        
        .status {
            margin-top: 20px;
            font-size: 1.2rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="overlay">
        <h1>STATIC</h1>
        <div class="status">HOLLYWOOD EDITION</div>
    </div>

    <script>
        // Three.js Scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xff0000, 2, 100);
        pointLight.position.set(0, 0, 10);
        scene.add(pointLight);

        // Create particle field
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 5000;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 50;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.05,
            color: 0xff0000,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // Create rotating cube with shader material
        const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                uniform float time;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    
                    vec3 pos = position;
                    pos.x += sin(position.y * 10.0 + time) * 0.1;
                    pos.y += cos(position.x * 10.0 + time) * 0.1;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vec2 position = vUv;
                    
                    float color = 0.0;
                    color += sin(position.x * cos(time / 15.0) * 80.0) + cos(position.y * cos(time / 15.0) * 10.0);
                    color += sin(position.y * sin(time / 10.0) * 40.0) + cos(position.x * sin(time / 25.0) * 40.0);
                    color += sin(position.x * sin(time / 5.0) * 10.0) + sin(position.y * sin(time / 35.0) * 80.0);
                    color *= sin(time / 10.0) * 0.5;
                    
                    gl_FragColor = vec4(vec3(color, color * 0.5, sin(color + time / 3.0) * 0.75), 1.0);
                }
            `,
            wireframe: true
        });
        
        const cube = new THREE.Mesh(cubeGeometry, shaderMaterial);
        scene.add(cube);

        camera.position.z = 10;

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Update shader uniforms
            shaderMaterial.uniforms.time.value += 0.01;
            
            // Rotate elements
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            particlesMesh.rotation.y += 0.001;
            
            // Move camera
            camera.position.x = Math.sin(Date.now() * 0.0005) * 5;
            camera.position.y = Math.cos(Date.now() * 0.0005) * 5;
            camera.lookAt(0, 0, 0);
            
            // Animate point light
            pointLight.position.x = Math.sin(Date.now() * 0.001) * 10;
            pointLight.position.y = Math.cos(Date.now() * 0.001) * 10;
            
            renderer.render(scene, camera);
        }
        
        animate();

        // GSAP Animations
        gsap.to('h1', {
            scale: 1.1,
            duration: 2,
            ease: "power2.inOut",
            yoyo: true,
            repeat: -1
        });

        // Anime.js text animation
        anime({
            targets: '.status',
            translateY: [-20, 20],
            duration: 3000,
            easing: 'easeInOutSine',
            direction: 'alternate',
            loop: true
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>